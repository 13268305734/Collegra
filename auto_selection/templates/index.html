<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>决策转盘</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    <div class="container">
        <div class="left-panel">
            <h2>决定转盘</h2>
            <canvas id="wheelCanvas"></canvas>
            <button onclick="spinWheel()" class="button">转动转盘</button>
             <div id="result"></div>
             <div id="error"></div>
        </div>
        <div class="right-panel">
            <h2>想做的事情</h2>
            <div id="options-input-container">
                <input type="text" class="option-input" placeholder="输入选项 1">
            </div>
            <button onclick="addOptionInput()" class="button" id="add-option-button">添加更多选项</button>
            <button onclick="saveOptions()" class="button" style="background-color: #ff9800;">保存选项</button>
            <button onclick="loadOptions()" class="button" style="background-color: #00bcd4;">加载选项</button>
            <button onclick="clearOptions()" class="button" style="background-color: #f44336;">清空选项</button>
        </div>
    </div>

    <script>
        const optionsInputContainer = document.getElementById('options-input-container');
        const wheelCanvas = document.getElementById('wheelCanvas');
        const resultDiv = document.getElementById('result');
        const errorDiv = document.getElementById('error');
        let options = [];
        let wheelDrawing = false;
        let currentRotation = 0; // To keep track of rotation for smooth stopping

        // Function to add a new option input field
        function addOptionInput(value = '') {
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'option-input';
            input.placeholder = `输入选项 ${optionsInputContainer.children.length + 1}`;
            input.value = value; // Set initial value if provided
            optionsInputContainer.appendChild(input);
            // Add event listener for Enter key on the new input
            input.addEventListener('keypress', function(event) {
                if (event.key === 'Enter') {
                    const inputs = optionsInputContainer.getElementsByClassName('option-input');
                    if (event.target === inputs[inputs.length - 1]) {
                        event.preventDefault();
                        addOptionInput();
                        const newInputs = optionsInputContainer.getElementsByClassName('option-input');
                        newInputs[newInputs.length - 1].focus();
                    }
                }
            });
            updateWheel(); // Redraw wheel when input is added
        }

        // Function to get options from input fields and draw the wheel
        function updateWheel() {
             if(wheelDrawing) return; // Prevent redrawing while spinning

             const currentOptions = Array.from(document.getElementsByClassName('option-input'))
                         .map(input => input.value.trim())
                         .filter(value => value !== ''); // Filter out empty options

            // Only redraw if options have changed
            if (JSON.stringify(currentOptions) !== JSON.stringify(options)) {
                options = currentOptions;
                 if (options.length === 0) {
                     // Clear canvas if no options
                     const ctx = wheelCanvas.getContext('2d');
                     ctx.clearRect(0, 0, wheelCanvas.width, wheelCanvas.height);
                 } else {
                     drawWheel(currentRotation); // Redraw with current rotation
                 }
            }
        }

        // Function to spin the wheel
        function spinWheel() {
             if (wheelDrawing) return; // Prevent multiple spins

             // Use the current options array which is updated by updateWheel
             if (options.length === 0) {
                 errorDiv.textContent = '请先添加一些选项';
                 resultDiv.textContent = '';
                 return;
             }

             errorDiv.textContent = '';
             resultDiv.textContent = '...';
             wheelDrawing = true; // Prevent redrawing during spin

             const spinningTime = 5000; // 5 seconds of spinning
             const spinInterval = 30; // Redraw every 30ms
             let currentTime = 0;
             const initialRotation = currentRotation;
             const totalRotation = 360 * 10 + Math.random() * 360; // Spin 10+ times

             const spinAnimation = setInterval(() => {
                  currentTime += spinInterval;
                  const progress = easeOutQuad(currentTime / spinningTime);
                  currentRotation = initialRotation + totalRotation * progress;
                  drawWheel(currentRotation);

                  if (currentTime >= spinningTime) {
                       clearInterval(spinAnimation);
                       makeDecisionBackend(); // Call backend to get the actual decision
                  }
             }, spinInterval);
        }

        // Easing function for animation
        function easeOutQuad(t) {
            return t * (2 - t);
        }

        // Draw wheel with rotation
        function drawWheel(rotation = 0) {
            const ctx = wheelCanvas.getContext('2d');
            const centerX = wheelCanvas.width / 2;
            const centerY = wheelCanvas.height / 2;
            const radius = Math.min(centerX, centerY) * 0.9;
            const arcSize = options.length > 0 ? 2 * Math.PI / options.length : 0;

            ctx.clearRect(0, 0, wheelCanvas.width, wheelCanvas.height);

            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(rotation * Math.PI / 180); // Apply rotation

            options.forEach((option, index) => {
                 const startAngle = index * arcSize;
                 const endAngle = (index + 1) * arcSize;

                 ctx.beginPath();
                 ctx.moveTo(0, 0);
                 ctx.arc(0, 0, radius, startAngle, endAngle);
                 ctx.closePath();
                 // Simple coloring based on index
                 ctx.fillStyle = `hsla(${index * (360 / options.length)}, 50%, 70%, 0.8)`; // Softer colors with some transparency
                 ctx.fill();
                 ctx.stroke();

                 // Add text
                 ctx.save();
                 ctx.rotate(startAngle + arcSize / 2);
                 ctx.textAlign = 'center';
                 ctx.fillStyle = '#555'; // Darker gray for text
                 ctx.font = '15px \'Inter\', \'Noto Serif SC\', sans-serif'; // Use consistent font stack and slightly smaller size
                 ctx.fillText(option, radius * 0.6, 0);
                 ctx.restore();
             });

            ctx.restore();

             // Draw pointer
            ctx.beginPath();
            ctx.moveTo(centerX, centerY - radius * 1.05);
            ctx.lineTo(centerX + 15, centerY - radius * 1.15);
            ctx.lineTo(centerX - 15, centerY - radius * 1.15);
            ctx.closePath();
            ctx.fillStyle = '#e53935'; // Red color
            ctx.fill();
            ctx.strokeStyle = '#b71c1c';
            ctx.stroke();

             // Draw center circle
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius * 0.1, 0, 2 * Math.PI);
            ctx.fillStyle = '#e0f0ff'; // Light blue from gradient
            ctx.fill();
            ctx.strokeStyle = '#b3e5fc'; // Border color from light blue
            ctx.stroke();
        }

        // Function to call backend for decision
        function makeDecisionBackend() {
             fetch('/make_decision', {
                 method: 'POST',
                 headers: {
                     'Content-Type': 'application/json',
                 },
                 body: JSON.stringify({ options: options })
             })
             .then(response => response.json())
             .then(data => {
                 if (data.error) {
                     errorDiv.textContent = data.error;
                     resultDiv.textContent = '';
                     wheelDrawing = false;
                 } else {
                     // Find the index of the selected option
                     const selectedOption = data.result;
                     const selectedIndex = options.indexOf(selectedOption);

                     if (selectedIndex !== -1) {
                          // Calculate the target rotation for the selected option
                          const arcSize = 360 / options.length;
                          // Aim for the middle of the segment
                          let targetAngle = (selectedIndex + 0.5) * arcSize;

                          // Convert current rotation to an angle between 0 and 360
                          const currentAngle = (currentRotation % 360 + 360) % 360;

                          // Calculate the shortest distance to the target angle
                          let angleDifference = targetAngle - currentAngle;

                          // Adjust for shortest path (clockwise or counter-clockwise)
                          if (angleDifference > 180) angleDifference -= 360;
                          if (angleDifference < -180) angleDifference += 360;

                           // Add some full spins to make it visually appealing
                          const spins = 5;
                          const totalAnimationRotation = currentRotation + angleDifference + spins * 360;

                          // Animate to the target rotation
                          const animationDuration = 3000; // 3 seconds for stopping animation
                          const animationInterval = 30;
                          let startRotation = currentRotation;
                          let startTime = null;

                          const easeOutCubic = (t) => (--t) * t * t + 1; // Easing function for stopping

                          const stopAnimation = (timestamp) => {
                               if (!startTime) startTime = timestamp;
                               const elapsed = timestamp - startTime;
                               const progress = Math.min(elapsed / animationDuration, 1);
                               const easedProgress = easeOutCubic(progress);
                               currentRotation = startRotation + (totalAnimationRotation - startRotation) * easedProgress;
                               drawWheel(currentRotation);

                               if (progress < 1) {
                                    requestAnimationFrame(stopAnimation);
                               } else {
                                    resultDiv.textContent = `决定：${data.result}`;
                                    errorDiv.textContent = '';
                                    wheelDrawing = false;
                                    currentRotation = totalAnimationRotation % 360; // Store final rotation normalized
                                    // Ensure rotation is positive
                                    if (currentRotation < 0) currentRotation += 360;
                               }
                          };

                          requestAnimationFrame(stopAnimation);

                     } else {
                          // Fallback if selected option is not found (shouldn't happen if backend is correct)
                          resultDiv.textContent = `决定：${data.result}`;
                          errorDiv.textContent = '';
                          wheelDrawing = false;
                     }
                 }
             })
             .catch(error => {
                 console.error('Error:', error);
                 errorDiv.textContent = '发生错误，请重试';
                 resultDiv.textContent = '';
                 wheelDrawing = false;
             });
        }

        // Function to save options to backend
        function saveOptions() {
             const currentOptions = Array.from(document.getElementsByClassName('option-input'))
                         .map(input => input.value.trim())
                         .filter(value => value !== '');

             fetch('/save_options', {
                 method: 'POST',
                 headers: {
                     'Content-Type': 'application/json',
                 },
                 body: JSON.stringify({ options: currentOptions })
             })
             .then(response => response.json())
             .then(data => {
                 if (data.error) {
                     errorDiv.textContent = data.error;
                 } else {
                     // Clear error message on success
                     errorDiv.textContent = '';
                     alert(data.message); // Provide user feedback
                 }
             })
             .catch(error => {
                 console.error('Error saving options:', error);
                 errorDiv.textContent = '保存选项时发生错误';
             });
        }

        // Function to load options from backend
        function loadOptions() {
            fetch('/load_options')
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        errorDiv.textContent = data.error;
                    } else {
                        // Clear existing input fields
                        optionsInputContainer.innerHTML = '';
                        // Add loaded options to input fields
                        if (data.options.length > 0) {
                            data.options.forEach(option => addOptionInput(option));
                        } else {
                            // If loaded options are empty, add one blank input field
                             addOptionInput();
                        }
                        // Clear error message on success
                        errorDiv.textContent = '';
                        updateWheel(); // Redraw wheel with loaded options
                         alert('选项加载成功！'); // Provide user feedback
                    }
                })
                .catch(error => {
                    console.error('Error loading options:', error);
                    errorDiv.textContent = '加载选项时发生错误';
                });
        }

        // Function to clear all options
        function clearOptions() {
             optionsInputContainer.innerHTML = ''; // Remove all input fields
             addOptionInput(); // Add one empty input field back
             updateWheel(); // Redraw wheel (should be blank)
             resultDiv.textContent = ''; // Clear result
             errorDiv.textContent = ''; // Clear error
        }

        // Initial draw and redraw on input change
        const resizeCanvas = () => {
             const containerWidth = wheelCanvas.parentElement.offsetWidth;
             wheelCanvas.width = containerWidth;
             wheelCanvas.height = containerWidth; // Keep it square
             updateWheel(); // Redraw wheel on resize
        };

        // Redraw wheel when input changes
        optionsInputContainer.addEventListener('input', updateWheel);

         // Add event listener for adding option on Enter key press in the last input field (delegated)
        // This listener was moved inside addOptionInput to handle new inputs dynamically.


        // Initial drawing and resize listener
        window.addEventListener('resize', resizeCanvas);

        // Load options when the page loads
        document.addEventListener('DOMContentLoaded', () => {
             loadOptions(); // Load options on page load
             resizeCanvas(); // Set initial canvas size and draw wheel
        });

    </script>
</body>
</html> 